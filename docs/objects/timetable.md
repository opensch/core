# Timetable (Расписание)

## Что это такое?
Расписание в openSchool - способ хранения порядка уроков для разных классов в разные дни для учеников. В отличие от обычного расписания, где есть название класса и таблица с предметами, кусочки расписания в openSchool храняться в другом и специфичном виде, который упрощает поиск в базе данных (в нашем случае - mongoDB).


## Где храниться и как использовать?
Расписания храняться в коллекции `timetable` в базе данных. Для того, чтобы подключиться к ней, введите:
```python
import classes

connection = classes.createMongo()
database = connection.timetable
```

Но более правильным способом работы с базой данных является класс `Timetable` (см. `classes/timetable/timetable.py` или документацию класса ниже).


## Структура блока расписания в базе данных
* `classNumber` -  номер класса
* `classLetter` - буква класса (если её нету, то `A`)
* `day` - номер дня, где 0 - понедельник, а 6 - воскресенье
* `lessons` - список с ID уроками

Заметка) В списке с уроками ID могут быть прописаны вместе с префиксами - знаками о том, какой это тип урока (индивидуальный, общий и т.д).


## Префиксы для уроков в расписании 
* `A` - урок для всего класса (все уроки для 1-9 класса, кроме рз. часа, имеют этот префикс)
* `I` - индивидуальный урок. При генерации расписания, будет использоваться `uniqLessons` у `User`. Развивающие часы заполняются с этим префиксом
* `,` - перебор уроков через запятую равносилен `I`
* Если префикса нет, то будет использоваться `A`


## А что это за переменная `MAX_LESSON_COUNT` в файле конфигурации?
В дизайне openSchool есть один промах. Списки с ID уроками в расписании должны иметь **одинаковую** длину для каждого дня в каждом классе, а пропуски в списке должны быть заполнены `-`. Если же в базе данных появится расписание с другой длиной списка уроков, это может привести к возрождению динозавров, восстанию машин и уничтожению человеческой жизни и всей её инфраструктуры, построенной за тысячелетия. Но не волнуйтесь! Это в параллельной вселенной. В нашей клиентское приложение просто не сможет вывести расписание. Или крашнется сервер, мы пока не знаем.

Поэтому для предотвращение таких 'странных' последствий от возможной неаккуратности программистов, есть переменная `MAX_LESSON_COUNT` в файле конфигурации (см. `config.py`). Выставляете максимальное количество уроков в школе и после этого **НЕ ТРОГАЙТЕ ЕЁ**! Иначе... Ну вы уже знаете...


## Документация класса `Timetable`
Переменные класса:
* `db` - подключение к части базы данных с расписанием
* `classNumber` - номер класса
* `classLetter` - буква класса
* `day` - день недели (от 0 до 6)
* `lessons` - список со строчками, в которых прописаны ID уроков и префиксы

Методы:
* `toJSON()` - переводит данные из текущей инстанции класса в Python словарь
	* Аргументы: 
		* ничего
	* Возращает: 
		* Python словарь


* `fromJSON()` - создает инстанцию класса `Timetable` из данных, которые находятся в указанном Python словаре.
	* Аргументы:
		* `jsonData` - Python словарь
	* Возращает: 
		* инстанция Python класса `Timetable`


* `init()` - создает кусочек расписания и сохраняет его в базе данных
	* Аргументы:
		* `class_number` - номер класса
		* `class_letter` - буква класса (ОБЯЗАТЕЛЬНО КИРИЛЛИЦЕЙ!)
		* `day` - день недели (от 0 до 6)
		* `lesson_array` - Python список, состоящий из строчек, в которых прописаны ID уроков и префиксы
	* Возращает при успехе: 
		* инстанция Python объекта `Timetable` с данными только что созданного куска расписания
	* Возращает при неудаче: 
		* тип `None`
		
* `edit()` - изменяет текущий кусок расписания (точнее, меняет список с уроками, остальное менять нет смысла)
	* Аргументы:
		* `new_lesson_array` - Python список, состоящий из строчек, в которых прописаны новые ID уроков и префиксы
	* Возращает при успехе: 
		* заменяет `self.lesson` на новый список; возращает `True`
	* Возращает при неудаче: 
		* тип `None`


* `delete()` - удаляет текущий кусок расписания из базы данных
	* Аргументы: 
		* нет
	* Возращает при успехе: 
		* `True`
	* Возращает при неудаче: 
		* тип `None`


* `createTimetable()` - формирует расписание для конкретного пользователя на нужный день, основывась на данных из базе данных и с учетом замен, если они есть.
	* Аргументы:
		* `user` - инстанция Python класса `User`
		* `date` - инстанция Python класса `datetime` c нужной датой
	* Возращает: 
		* инстанция Python класса `Timetable`


